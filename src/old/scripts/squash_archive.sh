#!/bin/bash
# File generated by AI

set -e

# --- Configuration ---
BOT_NAME="GitHub Actions"
BOT_EMAIL="41898282+github-actions[bot]@users.noreply.github.com"
BOT_MSG="Archive update"
TEMP_BRANCH="reconstructed-history"

# --- Helper Functions ---

log() {
    echo "[INFO] $*"
}

warn() {
    echo "[WARN] $*" >&2
}

error() {
    echo "[ERROR] $*" >&2
    exit 1
}

# Function to calculate checksum of tracked files
calculate_checksum() {
    if command -v sha256sum >/dev/null 2>&1; then
        # We use git ls-tree to get hashes of all tracked files.
        # This identifies the exact content of the repository.
        git ls-tree -r HEAD | awk '{print $3}' | sort | sha256sum | cut -d' ' -f1
    else
        echo "N/A"
    fi
}

# --- Main Logic ---

main() {
    # Move to the repository root
    cd "$(git rev-parse --show-toplevel)"

    # Get current branch
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    log "Current branch: $CURRENT_BRANCH"

    # Check if working directory is clean
    if [ -n "$(git status --porcelain)" ]; then
        error "You have uncommitted changes. Please stash or commit them before running."
    fi

    # Find the first bot commit to determine the base
    log "Searching for the first bot commit..."
    FIRST_BOT_SHA=$(git log --reverse --author="$BOT_NAME" --grep="$BOT_MSG" --pretty=format:"%H" "$CURRENT_BRANCH" | head -n 1)

    if [ -z "$FIRST_BOT_SHA" ]; then
        log "No bot commits found matching '$BOT_MSG' by '$BOT_NAME'. Nothing to squash."
        exit 0
    fi

    BASE_SHA=$(git rev-parse "$FIRST_BOT_SHA^")
    log "Base commit for reconstruction: $BASE_SHA"

    # Calculate initial checksum
    log "Analyzing history and calculating initial checksum..."
    INITIAL_CHECKSUM=$(calculate_checksum)

    # Collect manual commits
    log "Filtering manual commits..."
    # We use a custom format to easily parse commit metadata
    # %H: hash, %an: author name, %ae: author email, %at: author date (timestamp), %s: subject
    RAW_COMMITS=$(git log --reverse --pretty=format:"%H|%an|%ae|%at|%s" "$BASE_SHA..$CURRENT_BRANCH")
    
    MANUAL_COMMITS=()
    while IFS= read -r line; do
        [ -z "$line" ] && continue
        
        IFS='|' read -r SHA NAME EMAIL DATE MSG <<< "$line"

        # A commit is "manual" if it's NOT from the bot OR it has a different message
        if [[ ("$NAME" != "$BOT_NAME" && "$EMAIL" != "$BOT_EMAIL") || "$MSG" != "$BOT_MSG" ]]; then
            MANUAL_COMMITS+=("$line")
        fi
    done <<< "$RAW_COMMITS"

    TOTAL=${#MANUAL_COMMITS[@]}
    log "Found $TOTAL manual commits to transfer."

    # Prepare temporary branch
    if git show-ref --verify --quiet "refs/heads/$TEMP_BRANCH"; then
        if [ "$CURRENT_BRANCH" = "$TEMP_BRANCH" ]; then
            error "You are currently on the branch '$TEMP_BRANCH'. Switch to another branch first."
        fi
        log "Removing existing branch $TEMP_BRANCH..."
        git branch -D "$TEMP_BRANCH" > /dev/null
    fi

    # Create and switch to temporary branch at base
    git checkout -q -b "$TEMP_BRANCH" "$BASE_SHA"

    # Transfer manual commits
    COUNT=0
    for line in "${MANUAL_COMMITS[@]}"; do
        ((++COUNT)) # Fixed: using ++COUNT to avoid exit with set -e when COUNT is 0
        
        IFS='|' read -r SHA NAME EMAIL DATE MSG <<< "$line"

        echo "[$COUNT/$TOTAL] Picking: $SHA ($NAME): $MSG"
        
        # Preserve original author info as committer info
        export GIT_COMMITTER_NAME="$NAME"
        export GIT_COMMITTER_EMAIL="$EMAIL"
        export GIT_COMMITTER_DATE="@$DATE"

        # Apply changes. 'theirs' strategy prioritizes the commit we are picking in case of conflicts.
        git cherry-pick -q --strategy-option=theirs "$SHA" || {
            warn "Conflict in $SHA. Please resolve manually, then run 'git cherry-pick --continue'."
            warn "After resolving all conflicts, you will need to finish the script's steps manually."
            unset GIT_COMMITTER_NAME GIT_COMMITTER_EMAIL GIT_COMMITTER_DATE
            exit 1
        }
    done

    unset GIT_COMMITTER_NAME GIT_COMMITTER_EMAIL GIT_COMMITTER_DATE

    # Finalize archive state
    log "Creating final squashed 'Archive update' commit..."
    # Synchronize working tree with the original branch (all current files)
    git checkout -q "$CURRENT_BRANCH" -- .
    git add -A

    if ! git diff --cached --quiet; then
        GIT_COMMITTER_NAME="$BOT_NAME" GIT_COMMITTER_EMAIL="$BOT_EMAIL" \
        git commit -q -m "$BOT_MSG" --author="$BOT_NAME <$BOT_EMAIL>"
        log "Final squashed commit created."
    else
        log "No changes detected for the final commit."
    fi

    # Verify integrity
    FINAL_CHECKSUM=$(calculate_checksum)

    # Return to original branch
    git checkout -q "$CURRENT_BRANCH"

    # Aggressive cleanup
    echo ""
    log "Performing aggressive cleanup..."
    # Expire reflog to allow gc to remove old unreachable commits
    git reflog expire --expire=now --all
    # --aggressive: optimization, --prune=now: remove unreachable objects immediately
    git gc --aggressive --prune=now

    echo ""
    log "Successfully reconstructed history in branch: $TEMP_BRANCH"
    
    if [ "$INITIAL_CHECKSUM" != "N/A" ]; then
        if [ "$INITIAL_CHECKSUM" = "$FINAL_CHECKSUM" ]; then
            log "Integrity check PASSED: All files match the original state."
        else
            warn "Integrity check FAILED!"
            echo "  Original hash: $INITIAL_CHECKSUM"
            echo "  New hash:      $FINAL_CHECKSUM"
            echo "  Check differences with: git diff $CURRENT_BRANCH $TEMP_BRANCH"
        fi
    fi

    echo ""
    echo "To apply the new history, run:"
    echo "  git reset --hard $TEMP_BRANCH"
    echo ""
    warn "This will rewrite history. A 'push --force' may be required later."
}

main "$@"
